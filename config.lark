// general
// ================

?tok_ignore: COMMENT
           | ";" -> extra_semicolon

path: string
key: string
param: string
kernel_option_value: string

// kernel logic expressions
// ================

EXPR_CMP_GE:  ">"
EXPR_CMP_GEQ: ">="
EXPR_CMP_LE:  "<"
EXPR_CMP_LEQ: "<="
EXPR_CMP_NEQ: ( WS "is" WS "not" WS | "!=" )
EXPR_CMP_EQ:  ( WS "is" WS | "==" )

expr_id: KERNEL_OPTION
expr_op_neg: "not" WS
           | "!"
expr_op_cmp: EXPR_CMP_GE
           | EXPR_CMP_GEQ
           | EXPR_CMP_LE
           | EXPR_CMP_LEQ
           | EXPR_CMP_NEQ
           | EXPR_CMP_EQ

EXPR_STRING: /[_a-zA-Z0-9]+/
expr_string: ESCAPED_STRING -> string_quoted
           | EXPR_STRING    -> string
expr:         expr_term ( WS "or" WS expr_term | "||" expr_term )*
expr_term:    expr_factor ( WS "and" WS expr_term | "&&" expr_term )*
expr_cmp:     expr_string expr_op_cmp expr_string
?expr_factor: [ expr_op_neg ] expr_id
            | [ expr_op_neg ] "(" expr ")"
            | expr_cmp

_expr_ws: WS expr
        | "(" expr ")"

// module
// ================

module_name: IDENTIFIER

blck_module: "module" WS module_name "{" ctxt_module "}"
ctxt_module: ( tok_ignore
             | stmt_module_if
             | stmt_module_use
             | stmt_module_merge
             | stmt_module_assert
             | stmt_module_set )*
stmt_module_if:     "if"     _expr_ws "{" ctxt_module "}" ( "else" WS "if" _expr_ws "{" ctxt_module "}" )* [ "else" WS "{" ctxt_module "}" ]
stmt_module_use:    "use"    ( WS IDENTIFIER )+                          [ WS "if" _expr_ws ] ";"
stmt_module_merge:  "merge"  WS path                                     [ WS "if" _expr_ws ] ";"
stmt_module_assert: "assert" WS KERNEL_OPTION [ WS kernel_option_value ] [ WS "if" _expr_ws ] ";"
stmt_module_set:    "set"    WS KERNEL_OPTION [ WS kernel_option_value ] [ WS "if" _expr_ws ] ";"

// kernel
// ================

blck_kernel: "kernel" "{" ctxt_kernel "}"
// stmt_kernel_add_cmdline has to be before ctxt_module else the parser complains about infinite recursion. Seems to be a bug in lark.
ctxt_kernel: ( tok_ignore
             | stmt_kernel_add_cmdline
             | ctxt_module )*
stmt_kernel_add_cmdline: "add_cmdline" ( WS param )+ ";"

// genkernel
// ================

blck_genkernel: "genkernel" "{" ctxt_genkernel "}"
ctxt_genkernel: ( tok_ignore
                | stmt_genkernel_add_params )*
stmt_genkernel_add_params: "add_params" ( WS param )+ ";"

// initramfs
// ================

blck_initramfs: "initramfs" "{" ctxt_initramfs "}"
ctxt_initramfs: ( tok_ignore
                | blck_genkernel
                | stmt_initramfs_add_cmdline )*
stmt_initramfs_add_cmdline: "add_cmdline" ( WS param )+ ";"

// efi
// ================

blck_efi: "efi" "{" ctxt_efi "}"
ctxt_efi: ( tok_ignore )*

// install
// ================

blck_install: "install" "{" ctxt_install "}"
ctxt_install: ( tok_ignore
              | blck_efi
              | stmt_install_target_dir
              | stmt_install_target
              | stmt_install_mount
              | stmt_install_assert_mounted )*
stmt_install_target_dir:     "target_dir"     WS path ";"
stmt_install_target:         "target"         WS path ";"
stmt_install_mount:          "mount"          WS path ";"
stmt_install_assert_mounted: "assert_mounted" WS path ";"

// build
// ================

blck_build: "build" "{" ctxt_build "}"
ctxt_build: ( tok_ignore
            | stmt_build_initramfs
            | stmt_build_pack )*
stmt_build_initramfs: "initramfs" WS param ";"
stmt_build_pack: "pack" WS key [ WS param ] ";"

// root
// ================

blck_root: ctxt_root
ctxt_root: ( tok_ignore
           | blck_module
           | blck_kernel
           | blck_initramfs
           | blck_install
           | blck_build
           | stmt_root_include_module_dir
           | stmt_root_include_module )*

stmt_root_include_module_dir: "include_module_dir" WS path ";"
stmt_root_include_module:     "include_module"     WS path ";"

// terminals
// ================

KERNEL_OPTION: /[_A-Z0-9]+/
COMMENT:       /#[^\n]*/
IDENTIFIER:    ( "_" | "-" | LETTER | DIGIT )+

// The negative lookbehind avoids beeing greedy for the semicolon at the end
STRING: /\S+(?<!;)/
string: ESCAPED_STRING -> string_quoted
      | STRING         -> string

// meta
// ================

%import common.ESCAPED_STRING
%import common.LETTER
%import common.DIGIT
%import common.WS
%ignore WS
%ignore COMMENT
