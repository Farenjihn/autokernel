# vim: set ft=ruby ts=4 sw=4 sts=-1 noet:

# TODO credit to kssp, clipos, hardenedcheck

# TODO verify each symbol is assignable

module hardening {
	# Variables the user may want to modify these variables:
	# Before including this module:
	#  * MODULES <y/n>
	#  * DEVMEM <y/n>
	# After including this module:
	#  * MODULE_SIG_KEY "path/to/sigining_key.pem"

	# The hardening module requires at least kernel version 4.0.
	# Everything after 4.0 is manually guarded.
	assert $kernel_version >= 4.0 'hardening module is designed for kernel versions >= 4.0';

	# This unlocks extra configuration options we need
	set EXPERT y;

	# Preventing loading of modules prevents root from altering kernel memory,
	# if the user hasn't already set this
	try set MODULES n;
	# Prefer to not allow direct physical memory access,
	# if the user hasn't already set this
	try set DEVMEM n;

	if MODULES {
		# Enforce strict memory mappings permissions for loadable kernel modules.
		if $kernel_version >= 4.11 {
			set STRICT_MODULE_RWX y;
		} else {
			set DEBUG_SET_MODULE_RONX y;
		}

		# But if MODULES is enabled, at least they should be signed with a per-build key.
		set MODULE_SIG y;
		set MODULE_SIG_ALL y;
		# Set signature to SHA512
		set MODULE_SIG_SHA512 y;
		# Require signed modules
		set MODULE_SIG_FORCE y;
	}

	# Dangerous; enabling this allows direct physical memory writing.
	set ACPI_CUSTOM_METHOD n;

	# Dangerous; enabling this disables brk ASLR.
	set COMPAT_BRK n;

	# Dangerous; enabling this allows direct kernel memory writing.
	set DEVKMEM n;

	# Dangerous; exposes kernel text image layout.
	set PROC_KCORE n;

	# Dangerous; enabling this disables VDSO ASLR.
	set COMPAT_VDSO n;

	# Dangerous; enabling this allows replacement of running kernel.
	set KEXEC n;

	# Dangerous; enabling this allows replacement of running kernel.
	set HIBERNATION n;

	# Prior to v4.1, assists heap memory attacks
	set INET_DIAG n if $kernel_version < 4.1;

	# We do not want our kernel to support miscellaneous binary classes.
	# ELF binaries and interpreted scripts starting with a shebang are enough
	# Also easily confused by misconfigured userspace, keep off.
	set BINFMT_MISC n;

	# Use the modern PTY interface (devpts) only.
	set LEGACY_PTYS n;

	# If SELinux can be disabled at runtime, the LSM structures cannot be read-only; keep off.
	set SECURITY_SELINUX_DISABLE n;

	# Reboot devices immediately if kernel experiences an Oops.
	set PANIC_ON_OOPS y;
	set PANIC_TIMEOUT -1;

	# Based on https://kernsec.org/wiki/index.php/Kernel_Self_Protection_Project/Recommended_Settings
	# Report BUG() conditions and kill the offending process.
	set BUG y;

	# Enable hardware random
	set HW_RANDOM y;
	set HW_RANDOM_INTEL y;
	set HW_RANDOM_AMD y;

	# Enable Expose the TPM’s Random Number Generator (RNG) as a Hardware RNG (HWRNG) and
	# expose the TPM’s Random Number Generator (RNG) as a Hardware RNG (HWRNG)
	# device, allowing the kernel to collect randomness from it. See documentation
	# of RANDOM_TRUST_CPU and the rng_core.default_quality command line parameter
	# for supplementary information.
	set TCG_TPM;
	set HW_RANDOM_TPM y;

	# Enable the auditing infrastructure.
	set AUDIT y;

	# Make sure kernel page tables have safe permissions.
	set DEBUG_RODATA y if $kernel_version < 4.11;
	set DEBUG_KERNEL y;
	set STRICT_KERNEL_RWX y if $kernel_version >= 4.11;

	# Report any dangerous memory permissions (not available on all archs).
	set DEBUG_WX y if $kernel_version >= 4.4;

	# Use strong stack protector for best stack canary coverage.
	if $kernel_version >= 4.18 {
		set STACKPROTECTOR y;
		set STACKPROTECTOR_STRONG y;
	} else {
		set CC_STACKPROTECTOR_STRONG y;
	}

	# If you must have DEVMEM, at least enable STRICT mode
	if DEVMEM {
		set STRICT_DEVMEM y;
		set IO_STRICT_DEVMEM y if $kernel_version >= 4.5;
	}

	# Provides some protections against SYN flooding.
	set SYN_COOKIES y;

	# Perform additional validation of various commonly targeted structures.
	set DEBUG_CREDENTIALS y;
	set DEBUG_NOTIFIERS y;
	set DEBUG_LIST y;
	set DEBUG_SG y;
	set BUG_ON_DATA_CORRUPTION y if $kernel_version >= 4.10;
	set SCHED_STACK_END_CHECK y;

	# Provide userspace with seccomp BPF API for syscall attack surface reduction.
	set SECCOMP y;

	# Provide userspace with ptrace ancestry protections.
	set SECURITY y;
	set SECURITY_YAMA y;

	# Perform usercopy bounds checking. (And disable fallback to gain full whitelist enforcement.)
	if $kernel_version >= 4.8 {
		set HARDENED_USERCOPY y;
		set HARDENED_USERCOPY_PAGESPAN n;
		set HARDENED_USERCOPY_FALLBACK n if $kernel_version >= 4.16;
	}

	# Randomize allocator freelists.
	set SLAB_FREELIST_RANDOM y if $kernel_version >= 4.7;
	# Harden slab metadata.
	set SLAB_FREELIST_HARDENED y if $kernel_version >= 4.14;

	# Randomize high-order page allocation freelist.
	# Page allocator randomization is primarily a performance improvement for direct-mapped
	# memory-side-cache utilization, but it does reduce the predictability of page allocations
	# and thus complements SLAB_FREELIST_RANDOM. The page_alloc.shuffle=1 parameter needs to
	# be added to the kernel command line.
	if $kernel_version >= 5.2 {
		set SHUFFLE_PAGE_ALLOCATOR y;
		add_cmdline "page_alloc.shuffle=1";
	}

	if $kernel_version >= 5.3 {
		# Wipe slab and page allocations
		# This replaces "slub_debug=P" and "page_poison=1" and can control all types
		# of memory allocation and wiping now. The init_on_free is only needed if there
		# is concern about minimizing stale data lifetime.
		set INIT_ON_ALLOC_DEFAULT_ON y;
		set INIT_ON_FREE_DEFAULT_ON y;
	} else {
		if $kernel_version < 5.3 {
			# Allow and enable allocator validation checking.
			set SLUB_DEBUG y;
			set SLUB_DEBUG_ON y;
		}

		if $kernel_version >= 4.6 {
			# Wipe higher-level memory allocations when they are freed (needs "page_poison=1").
			set PAGE_POISONING y;
			# Enable buddy allocator free poisoning.
			add_cmdline "page_poison=1";
			# If you can't afford even more performance penalty, set PAGE_POISONING_NO_SANITY=y
			# This only works if HIBERNATION is disabled, as it selects PAGE_POISONING_NO_SANITY.
			set PAGE_POISONING_NO_SANITY n if not HIBERNATION;
			set PAGE_POISONING_ZERO y;
		}
	}

	# Initialize all stack variables on function entry, with
	if $kernel_version >= 5.2 and CC_HAS_AUTO_VAR_INIT {
		set INIT_STACK_ALL y;
	} else if $kernel_version >= 5.2 and HAVE_GCC_PLUGINS {
		# Force all structures to be initialized before they are passed to other functions.
		# When building with GCC:
		set GCC_PLUGIN_STRUCTLEAK_BYREF_ALL y;
	}

	# Virtually-mapped stacks benefit from guard pages, thus making kernel stack overflows harder to exploit.
	set VMAP_STACK y if $kernel_version >= 4.9;

	# Perform extensive checks on reference counting. (Unconditionally enabled since 5.5)
	set REFCOUNT_FULL y if $kernel_version >= 4.13 and $kernel_version < 5.5;

	# Check for memory copies that might overflow a structure in str*() and mem*() functions both at build-time and run-time.
	set FORTIFY_SOURCE y if $kernel_version >= 4.13;

	if $kernel_version >= 4.8 and HAVE_GCC_PLUGINS {
		# Enable GCC Plugins
		set GCC_PLUGINS y;

		# Gather additional entropy at boot time for systems that may not have appropriate entropy sources.
		set GCC_PLUGIN_LATENT_ENTROPY y if $kernel_version >= 4.9;

		# Wipe stack contents on syscall exit (reduces stale data lifetime in stack)
		if $kernel_version >= 5.2 {
			set GCC_PLUGIN_STACKLEAK y;
			set STACKLEAK_METRICS n;
			set STACKLEAK_RUNTIME_DISABLE n;
		}

		# Randomize the layout of system structures. This may have dramatic performance impact, so
		# use with caution or also use GCC_PLUGIN_RANDSTRUCT_PERFORMANCE y;
		if $kernel_version >= 4.13 {
			set GCC_PLUGIN_RANDSTRUCT y;
			set GCC_PLUGIN_RANDSTRUCT_PERFORMANCE n;
		}
	}

	if X86 {
		# Disallow allocating the first 64k of memory.
		# This should in particular be non-zero to prevent the exploitation of kernel NULL pointer bugs.
		set DEFAULT_MMAP_MIN_ADDR 65536;

		# Enable Kernel Page Table Isolation to remove an entire class of cache timing side-channels.
		set PAGE_TABLE_ISOLATION y if $kernel_version >= 4.15;
		# Don't allow for 16-bit program emulation and associated LDT tricks.
		set MODIFY_LDT_SYSCALL n if $kernel_version >= 4.3;

		# Randomize position of kernel (requires UEFI RNG or bootloader support for /chosen/kaslr-seed DT property).
		set RANDOMIZE_BASE y;

		# Machine Check Exceptions can report suspicious hardware errors, some of which may for instance,
		# on systems with ECC memory, reveal an ongoing Rowhammer attack.
		set X86_MCE y;
		set X86_MCE_INTEL y;
		set X86_MCE_AMD y;

		# Page Attribute Tables are the modern equivalents of MTRRs (Memory Type Range Registers) which
		# can make speculative execution bugs a bit harder to exploit.
		set X86_PAT y;
	}

	if X86_64 {
		set RANDOMIZE_MEMORY y if $kernel_version >= 4.8;
		# The vsyscall table is not required anymore by libc and is a fixed-position potential source of ROP gadgets.
		set LEGACY_VSYSCALL_NONE y if $kernel_version >= 4.4;
		set X86_VSYSCALL_EMULATION n;
		# Remove additional attack surface, unless you really need them.
		try set IA32_EMULATION n;
		# Disable native x32 ABI
		set X86_X32 n;
	} else if X86 {
		# On 32-bit kernels, require PAE for NX bit support.
		set M486 n;
		set HIGHMEM4G n;
		set HIGHMEM64G y;
		set X86_PAE y;
	} else if $arch == "arm64" {
		# Disallow allocating the first 32k of memory (cannot be 64k due to ARM loader).
		set DEFAULT_MMAP_MIN_ADDR 32768;

		# Make sure PAN emulation is enabled.
		set ARM64_SW_TTBR0_PAN y if $kernel_version >= 4.10;

		# Enable Kernel Page Table Isolation to remove an entire class of cache timing side-channels.
		set UNMAP_KERNEL_AT_EL0 y if $kernel_version >= 4.16;
	} else if $arch == "arm" {
		# Disallow allocating the first 32k of memory (cannot be 64k due to ARM loader).
		set DEFAULT_MMAP_MIN_ADDR 32768;

		# For maximal userspace memory area (and maximum ASLR).
		set VMSPLIT_3G y;

		# If building an old out-of-tree Qualcomm kernel, this is similar to STRICT_KERNEL_RWX.
		set STRICT_MEMORY_RWX y;

		# Make sure PXN/PAN emulation is enabled.
		set CPU_SW_DOMAIN_PAN y if $kernel_version >= 4.3;

		# Dangerous; old interfaces and needless additional attack surface.
		set OABI_COMPAT n;
	}

	#kernel command line options

	# Disable slab merging (makes many heap overflow attacks more difficult).
	add_cmdline "slab_nomerge";

	# Always enable Kernel Page Table Isolation, even if the CPU claims it is safe from Meltdown.
	add_cmdline "pti=on";
}

module hardening_ {
	# Merging SLAB pages can make heap exploitation easier
	set SLAB_MERGE_DEFAULT n if $kernel_version >= 4.13;

	if $kernel_version >= 4.19 {
		# Do not credit entropy generated by the CPU manufacturer’s HWRNG
		# nor provided by the bootloader, and included in Linux’s entropy pool.
		# Fast and robust initialization of Linux’s CSPRNG is instead achieved
		# thanks to the TPM’s HWRNG (see documentation of HW_RANDOM_TPM and the
		# rng_core.default_quality command line parameter).
		set RANDOM_TRUST_CPU n;
		set RANDOM_TRUST_BOOTLOADER n;
	}

	# Disable /dev/cpu/*/{msr,cpuid} which would only present userspace with more attack surface.
	set X86_MSR n;
	set X86_CPUID n;






	if $kernel_version >= 5.6 {
		set PTDUMP_DEBUGFS n;
	} else {
		set X86_PTDUMP n;
	}
	set ZSMALLOC_STAT n;
	set PAGE_OWNER n;
	set DEBUG_KMEMLEAK n;
	set BINFMT_AOUT n;
	set KPROBES n;
	# To set UPROBES to n, we need to disable UPROBE_EVENTS
	set UPROBE_EVENTS n;
	set PROC_VMCORE n;
	set PROC_PAGE_MONITOR n;
	set USELIB n;
	set CHECKPOINT_RESTORE n;
	# The userfaultfd() system call adds attack surface and can make heap sprays easier.
	# Note that the vm.unprivileged_userfaultfd sysctl can also be used to restrict the
	# use of this system call to privileged users.
	set USERFAULTFD n if $kernel_version >= 4.3;
	set HWPOISON_INJECT n;
	set MEM_SOFT_DIRTY n;
	set DEVPORT n;
	try set DEBUG_FS n;
	set NOTIFIER_ERROR_INJECTION n;
	set ACPI_TABLE_UPGRADE n if $kernel_version >= 4.7;
	set ACPI_APEI_EINJ n;
	set PROFILING n;
	set BPF_SYSCALL n;
	set MMIOTRACE_TEST n;
	# Enabling this feature can make cache side-channel attacks such as FLUSH+RELOAD much easier to carry out.
	set KSM n;
	# Symbols are only useful for debug and attack purposes.
	set KALLSYMS n;
	set MAGIC_SYSRQ n;
	set KEXEC_FILE n;
	# User namespaces can be useful for some use cases but even more to an attacker.
	set USER_NS n;
	set LDISC_AUTOLOAD n if $kernel_version >= 5.1;
	set MMIOTRACE n;
	set LIVEPATCH n;
	set IP_DCCP n;
	set IP_SCTP n;
	set FTRACE n;
	set BPF_JIT n;

	# Needed to benefit from microcode updates and thus security fixes (e.g., additional Intel
	# pseudo-MSRs to be used by the kernel as a mitigation for various speculative execution vulnerabilities).
	set MICROCODE y;
	# Retpolines are needed to protect against Spectre v2. GCC 7.3.0 or higher is required.
	set RETPOLINE y if $kernel_version >= 4.15;
	set X86_SMAP y;
	if $kernel_version >= 5.5 {
		set X86_UMIP y;
	} else if $kernel_version >= 4.15 {
		set X86_INTEL_UMIP y;
	}
	set IOMMU_SUPPORT y;
	set INTEL_IOMMU y;
	set AMD_IOMMU y;

	set SECURITY_DMESG_RESTRICT y;
	set DEBUG_VIRTUAL y;
	set STATIC_USERMODEHELPER y if $kernel_version >= 4.11;
	set INTEL_IOMMU_SVM y if $kernel_version >= 4.4;
	set INTEL_IOMMU_DEFAULT_ON y;
	set SLUB_DEBUG_ON y;
	set RESET_ATTACK_MITIGATION y if $kernel_version >= 4.14;
	set AMD_IOMMU_V2 y;
	# TODO requires cmdline or the default-enable option, which we can use if initrd is false
	set SECURITY_LOADPIN y if $kernel_version >= 4.7;
	if $kernel_version >= 5.4 {
		set SECURITY_LOCKDOWN_LSM y;
		set SECURITY_LOCKDOWN_LSM_EARLY y;
		set LOCK_DOWN_KERNEL_FORCE_CONFIDENTIALITY y;
	}

	# Use maximum number of randomized bits for the mmap base address on x86_64.
	set ARCH_MMAP_RND_BITS "32" if $kernel_version >= 4.5;
}
