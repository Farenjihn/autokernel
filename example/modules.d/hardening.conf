# vim: set ft=ruby ts=4 sw=4 sts=-1 noet:

# TODO verify each symbol is assignable

# Edit these to fit your needs
module hardening_user {
	# If modules are needed, provide a siging key
	if MODULES {
	}
}

module hardening {
	# Variables the user may want to modify these variables:
	# Before including this module:
	#  * MODULES <y/n>
	#  * DEVMEM <y/n>
	# After including this module:
	#  * MODULE_SIG_KEY "path/to/sigining_key.pem"

	# The hardening module requires at least kernel version 4.0.
	# Everything after 4.0 is manually guarded.
	assert $kernel_version >= 4.0 'hardening module is designed for kernel versions >= 4.0';

	# Preventing loading of modules prevents root from altering kernel memory,
	# if the user hasn't already set this
	try set MODULES n;
	# Prefer to not allow direct physical memory access,
	# if the user hasn't already set this
	try set DEVMEM n;

	# But if MODULE y; is needed, at least they must be signed with a per-build key.
	if MODULES {
		if $kernel_version >= 4.11 {
			set STRICT_MODULE_RWX y;
		} else {
			set DEBUG_SET_MODULE_RONX y;
		}
		set MODULE_SIG y;
		set MODULE_SIG_ALL y;
		# Set signature to SHA512
		set MODULE_SIG_SHA512 y;
		# Require signed modules
		set MODULE_SIG_FORCE y;
	}

	# Dangerous; enabling this allows direct physical memory writing.
	set ACPI_CUSTOM_METHOD n;

	# Dangerous; enabling this disables brk ASLR.
	set COMPAT_BRK n;

	# Dangerous; enabling this allows direct kernel memory writing.
	set DEVKMEM n;

	# Dangerous; exposes kernel text image layout.
	set PROC_KCORE n;

	# Dangerous; enabling this disables VDSO ASLR.
	set COMPAT_VDSO n;

	# Dangerous; enabling this allows replacement of running kernel.
	set KEXEC n;

	# Dangerous; enabling this allows replacement of running kernel.
	set HIBERNATION n;

	# Prior to v4.1, assists heap memory attacks
	set INET_DIAG n if $kernel_version < 4.1;

	# Easily confused by misconfigured userspace, keep off.
	set BINFMT_MISC n;

	# Use the modern PTY interface (devpts) only.
	set LEGACY_PTYS n;

	# If SELinux can be disabled at runtime, the LSM structures cannot be read-only; keep off.
	set SECURITY_SELINUX_DISABLE n;

	# Reboot devices immediately if kernel experiences an Oops.
	set PANIC_ON_OOPS y;
	set PANIC_TIMEOUT -1;

	# Based on https://kernsec.org/wiki/index.php/Kernel_Self_Protection_Project/Recommended_Settings
	# Report BUG() conditions and kill the offending process.
	set BUG y;

	# Make sure kernel page tables have safe permissions.
	set DEBUG_RODATA y if $kernel_version < 4.11;
	set DEBUG_KERNEL y;
	set STRICT_KERNEL_RWX y if $kernel_version >= 4.11;

	# Report any dangerous memory permissions (not available on all archs).
	set DEBUG_WX y if $kernel_version >= 4.4;

	# Use strong stack protector for best stack canary coverage.
	if $kernel_version >= 4.18 {
		set STACKPROTECTOR y;
		set STACKPROTECTOR_STRONG y;
	} else {
		set CC_STACKPROTECTOR_STRONG y;
	}

	# If you must have DEVMEM, at least enable STRICT mode
	if DEVMEM {
		set STRICT_DEVMEM y;
		set IO_STRICT_DEVMEM y if $kernel_version >= 4.5;
	}

	# Provides some protections against SYN flooding.
	set SYN_COOKIES y;

	# Perform additional validation of various commonly targeted structures.
	set DEBUG_CREDENTIALS y;
	set DEBUG_NOTIFIERS y;
	set DEBUG_LIST y;
	set DEBUG_SG y;
	set BUG_ON_DATA_CORRUPTION y if $kernel_version >= 4.10;
	set SCHED_STACK_END_CHECK y;

	# Provide userspace with seccomp BPF API for syscall attack surface reduction.
	set SECCOMP y;

	# Provide userspace with ptrace ancestry protections.
	set SECURITY y;
	set SECURITY_YAMA y;

	# Perform usercopy bounds checking. (And disable fallback to gain full whitelist enforcement.)
	if $kernel_version >= 4.8 {
		set HARDENED_USERCOPY y;
		set HARDENED_USERCOPY_PAGESPAN n;
		set HARDENED_USERCOPY_FALLBACK n if $kernel_version >= 4.16;
	}

	# Randomize allocator freelists, harden metadata.
	set SLAB_FREELIST_RANDOM y if $kernel_version >= 4.7;
	set SLAB_FREELIST_HARDENED y if $kernel_version >= 4.14;

	# Randomize high-order page allocation freelist.
	set SHUFFLE_PAGE_ALLOCATOR y if $kernel_version >= 5.2;

	if $kernel_version >= 5.3 {
		# Wipe slab and page allocations
		# This replaces "slub_debug=P" and "page_poison=1" and can control all types
		# of memory allocation and wiping now. The init_on_free is only needed if there
		# is concern about minimizing stale data lifetime.
		set INIT_ON_ALLOC_DEFAULT_ON y;
		set INIT_ON_FREE_DEFAULT_ON y;
	} else {
		if $kernel_version < 5.3 {
			# Allow allocator validation checking to be enabled (needs "slub_debug=P").
			set SLUB_DEBUG y;
			# Enable slub/slab allocator free poisoning (requires SLUB_DEBUG y; above).
			add_cmdline "slub_debug=P";
		}

		if $kernel_version >= 4.6 {
			# Wipe higher-level memory allocations when they are freed (needs "page_poison=1").
			set PAGE_POISONING y;
			# Enable buddy allocator free poisoning.
			add_cmdline "page_poison=1";
			# If you can't afford even more performance penalty, set PAGE_POISONING_NO_SANITY=y
			# This only works if HIBERNATION is disabled, as it selects PAGE_POISONING_NO_SANITY.
			set PAGE_POISONING_NO_SANITY n if not HIBERNATION;
			set PAGE_POISONING_ZERO y;
		}
	}

	# Initialize all stack variables on function entry, with
	if $kernel_version >= 5.2 and CC_HAS_AUTO_VAR_INIT {
		set INIT_STACK_ALL y;
	} else if $kernel_version >= 5.2 and HAVE_GCC_PLUGINS {
		# Force all structures to be initialized before they are passed to other functions.
		# When building with GCC:
		set GCC_PLUGIN_STRUCTLEAK_BYREF_ALL y;
	}

	# Adds guard pages to kernel stacks (not all architectures support this yet).
	set VMAP_STACK y if $kernel_version >= 4.9;

	# Perform extensive checks on reference counting. (Unconditionally enabled since 5.5)
	set REFCOUNT_FULL y if $kernel_version >= 4.13 and $kernel_version < 5.5;

	# Check for memory copies that might overflow a structure in str*() and mem*() functions both at build-time and run-time.
	set FORTIFY_SOURCE y if $kernel_version >= 4.13;

	if $kernel_version >= 4.8 and HAVE_GCC_PLUGINS {
		# Enable GCC Plugins
		set GCC_PLUGINS y;

		# Gather additional entropy at boot time for systems that may not have appropriate entropy sources.
		set GCC_PLUGIN_LATENT_ENTROPY y if $kernel_version >= 4.9;

		# Wipe stack contents on syscall exit (reduces stale data lifetime in stack)
		set GCC_PLUGIN_STACKLEAK y if $kernel_version >= 5.2;

		# Randomize the layout of system structures. This may have dramatic performance impact, so
		# use with caution or also use GCC_PLUGIN_RANDSTRUCT_PERFORMANCE y;
		if $kernel_version >= 4.13 {
			set GCC_PLUGIN_RANDSTRUCT y;
			set GCC_PLUGIN_RANDSTRUCT_PERFORMANCE n;
		}
	}

	if X86 {
		# Disallow allocating the first 64k of memory.
		set DEFAULT_MMAP_MIN_ADDR 65536;

		# Enable Kernel Page Table Isolation to remove an entire class of cache timing side-channels.
		set PAGE_TABLE_ISOLATION y if $kernel_version >= 4.15;
		# Don't allow for 16-bit program emulation and associated LDT tricks.
		set MODIFY_LDT_SYSCALL n if $kernel_version >= 4.3;

		# Randomize position of kernel (requires UEFI RNG or bootloader support for /chosen/kaslr-seed DT property).
		set RANDOMIZE_BASE y;
	}

	if X86_64 {
		set RANDOMIZE_MEMORY y if $kernel_version >= 4.8;
		# Modern libc no longer needs a fixed-position mapping in userspace, remove it as a possible target.
		set LEGACY_VSYSCALL_NONE y if $kernel_version >= 4.4;
		# Remove additional attack surface, unless you really need them.
		try set IA32_EMULATION n;
		# Disable native x32 ABI
		set X86_X32 n;
	} else if X86 {
		# On 32-bit kernels, require PAE for NX bit support.
		set M486 n;
		set HIGHMEM4G n;
		set HIGHMEM64G y;
		set X86_PAE y;
	} else if $arch == "arm64" {
		# Disallow allocating the first 32k of memory (cannot be 64k due to ARM loader).
		set DEFAULT_MMAP_MIN_ADDR 32768;

		# Make sure PAN emulation is enabled.
		set ARM64_SW_TTBR0_PAN y if $kernel_version >= 4.10;

		# Enable Kernel Page Table Isolation to remove an entire class of cache timing side-channels.
		set UNMAP_KERNEL_AT_EL0 y if $kernel_version >= 4.16;
	} else if $arch == "arm" {
		# Disallow allocating the first 32k of memory (cannot be 64k due to ARM loader).
		set DEFAULT_MMAP_MIN_ADDR 32768;

		# For maximal userspace memory area (and maximum ASLR).
		set VMSPLIT_3G y;

		# If building an old out-of-tree Qualcomm kernel, this is similar to STRICT_KERNEL_RWX.
		set STRICT_MEMORY_RWX y;

		# Make sure PXN/PAN emulation is enabled.
		set CPU_SW_DOMAIN_PAN y if $kernel_version >= 4.3;

		# Dangerous; old interfaces and needless additional attack surface.
		set OABI_COMPAT n;
	}

	#kernel command line options

	# Disable slab merging (makes many heap overflow attacks more difficult).
	add_cmdline "slab_nomerge";

	# Always enable Kernel Page Table Isolation, even if the CPU claims it is safe from Meltdown.
	add_cmdline "pti=on";
}

module hardening_ {
	set SLAB_MERGE_DEFAULT n if $kernel_version >= 4.13;
	if $kernel_version >= 5.2 {
		set STACKLEAK_METRICS n;
		set STACKLEAK_RUNTIME_DISABLE n;
	}
	if $kernel_version >= 4.19 {
		set RANDOM_TRUST_CPU n;
	}
	#set DEVMEM n;
	if $kernel_version >= 5.6 {
		set PTDUMP_DEBUGFS n;
	} else {
		set X86_PTDUMP n;
	}
	set ZSMALLOC_STAT n;
	set PAGE_OWNER n;
	set DEBUG_KMEMLEAK n;
	set BINFMT_AOUT n;
	set KPROBES n;
	# To set UPROBES to n, we need to set UPROBE_EVENTS
	set UPROBE_EVENTS n;
	set PROC_VMCORE n;
	set PROC_PAGE_MONITOR n;
	set USELIB n;
	set CHECKPOINT_RESTORE n;
	set USERFAULTFD n if $kernel_version >= 4.3;
	set HWPOISON_INJECT n;
	set MEM_SOFT_DIRTY n;
	set DEVPORT n;
	try set DEBUG_FS n;
	set NOTIFIER_ERROR_INJECTION n;
	set ACPI_TABLE_UPGRADE n if $kernel_version >= 4.7;
	set ACPI_APEI_EINJ n;
	set PROFILING n;
	set BPF_SYSCALL n;
	set MMIOTRACE_TEST n;
	set KSM n;
	set KALLSYMS n;
	set X86_VSYSCALL_EMULATION n;
	set MAGIC_SYSRQ n;
	set KEXEC_FILE n;
	set USER_NS n;
	set LDISC_AUTOLOAD n if $kernel_version >= 5.1;
	set MMIOTRACE n;
	set LIVEPATCH n;
	set IP_DCCP n;
	set IP_SCTP n;
	set FTRACE n;
	set BPF_JIT n;

	set MICROCODE y;
	set RETPOLINE y if $kernel_version >= 4.15;
	set X86_SMAP y;
	if $kernel_version >= 5.5 {
		set X86_UMIP y;
	} else if $kernel_version >= 4.15 {
		set X86_INTEL_UMIP y;
	}
	set IOMMU_SUPPORT y;
	set INTEL_IOMMU y;
	set AMD_IOMMU y;

	set SECURITY_DMESG_RESTRICT y;
	set DEBUG_VIRTUAL y;
	set STATIC_USERMODEHELPER y if $kernel_version >= 4.11;
	set INTEL_IOMMU_SVM y if $kernel_version >= 4.4;
	set INTEL_IOMMU_DEFAULT_ON y;
	set SLUB_DEBUG_ON y;
	set RESET_ATTACK_MITIGATION y if $kernel_version >= 4.14;
	set AMD_IOMMU_V2 y;
	# TODO requires cmdline or the default-enable option, which we can use if initrd is false
	set SECURITY_LOADPIN y if $kernel_version >= 4.7;
	if $kernel_version >= 5.4 {
		set SECURITY_LOCKDOWN_LSM y;
		set SECURITY_LOCKDOWN_LSM_EARLY y;
		set LOCK_DOWN_KERNEL_FORCE_CONFIDENTIALITY y;
	}
	set ARCH_MMAP_RND_BITS "32" if $kernel_version >= 4.5;
}
