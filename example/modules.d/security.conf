# vim: set ft=ruby ts=4 sw=4 sts=-1 noet:

# TODO verify each symbol is assignable

# Edit these to fit your needs
module security_user {
	# Preventing loading of modules prevents root from altering kernel memory.
	set MODULES n;
	# Prefer to not allow direct physical memory access
	set DEVMEM n;
	# If modules are needed, provide a siging key
	if MODULES {
		set MODULE_SIG_KEY "certs/signing_key.pem";
	}
}

module security_ {
	# Security module requires at least kernel version 4.0.
	# Everything after 4.0 is manually guarded.
	assert $kernel_version >= 4.0 "security module is only designed for kernel versions >= 4.0";

	# But if MODULE y; is needed, at least they must be signed with a per-build key.
	if MODULES {
		if $kernel_version >= 4.11 {
			set STRICT_MODULE_RWX y;
		} else {
			set DEBUG_SET_MODULE_RONX y;
		}
		set MODULE_SIG y;
		set MODULE_SIG_ALL y;
		# Set signature to SHA512
		set MODULE_SIG_SHA512 y;
		# Require signed modules
		set MODULE_SIG_FORCE y;
	}

	# Based on https://kernsec.org/wiki/index.php/Kernel_Self_Protection_Project/Recommended_Settings
	# Report BUG() conditions and kill the offending process.
	set BUG y;

	# Make sure kernel page tables have safe permissions.
	set DEBUG_RODATA y if $kernel_version < 4.11;
	set DEBUG_KERNEL y;
	set STRICT_KERNEL_RWX y if $kernel_version >= 4.11;

	# Report any dangerous memory permissions (not available on all archs).
	set DEBUG_WX y if $kernel_version >= 4.4;

	# Use -fstack-protector-strong (gcc 4.9+) for best stack canary coverage.
	if $kernel_version >= 4.18 {
		set STACKPROTECTOR y;
		set STACKPROTECTOR_STRONG y;
	} else {
		set CC_STACKPROTECTOR_STRONG y;
	}

	# If you must have DEVMEM, at least enable STRICT mode
	if DEVMEM {
		set STRICT_DEVMEM y;
		set IO_STRICT_DEVMEM y if $kernel_version >= 4.5;
	}

	# Provides some protections against SYN flooding.
	set SYN_COOKIES y;

	# Perform additional validation of various commonly targeted structures.
	set DEBUG_CREDENTIALS y;
	set DEBUG_NOTIFIERS y;
	set DEBUG_LIST y;
	set DEBUG_SG y;
	set BUG_ON_DATA_CORRUPTION y if $kernel_version >= 4.10;
	set SCHED_STACK_END_CHECK y;

	# Provide userspace with seccomp BPF API for syscall attack surface reduction.
	set SECCOMP y;

	# Provide userspace with ptrace ancestry protections.
	set SECURITY y;
	set SECURITY_YAMA y;

	# Perform usercopy bounds checking. (And disable fallback to gain full whitelist enforcement.)
	set HARDENED_USERCOPY y          if $kernel_version >= 4.8;
	set HARDENED_USERCOPY_PAGESPAN n if $kernel_version >= 4.8;
	set HARDENED_USERCOPY_FALLBACK n if $kernel_version >= 4.16;

	# Randomize allocator freelists, harden metadata.
	set SLAB_FREELIST_RANDOM y if $kernel_version >= 4.7;
	set SLAB_FREELIST_HARDENED y if $kernel_version >= 4.14;

	# Randomize high-order page allocation freelist.
	set SHUFFLE_PAGE_ALLOCATOR y if $kernel_version >= 5.2;

	# Allow allocator validation checking to be enabled (see "slub_debug=P" below).
	set SLUB_DEBUG y;

	# Wipe higher-level memory allocations when they are freed (needs "page_poison=1" on cmdline).
	if $kernel_version >= 4.6 {
		set PAGE_POISONING y;
		# Enable buddy allocator free poisoning.
		add_cmdline "page_poison=1" if PAGE_POISONING;
		# If you can't afford even more performance penalty, set PAGE_POISONING_NO_SANITY=y
		# This only works if HIBERNATION is disabled, as it selects PAGE_POISONING_NO_SANITY.
		set PAGE_POISONING_NO_SANITY n if not HIBERNATION;
		set PAGE_POISONING_ZERO y;
	}

	# Wipe slab and page allocations
	# Instead of "slub_debug=P" and "page_poison=1", a single place can control memory allocation wiping now.
	# The init_on_free is only needed if there is concern about minimizing stale data lifetime.
	if $kernel_version >= 5.3 {
		set INIT_ON_ALLOC_DEFAULT_ON y;
		set INIT_ON_FREE_DEFAULT_ON y;
	}

	# Initialize all stack variables on function entry, with
	if $kernel_version >= 5.2 and CC_HAS_AUTO_VAR_INIT {
		set INIT_STACK_ALL y;
	} else if $kernel_version >= 5.2 and HAVE_GCC_PLUGINS {
		# Force all structures to be initialized before they are passed to other functions.
		# When building with GCC:
		set GCC_PLUGIN_STRUCTLEAK_BYREF_ALL y;
	}

	# Adds guard pages to kernel stacks (not all architectures support this yet).
	set VMAP_STACK y if $kernel_version >= 4.9;

	# Perform extensive checks on reference counting. (Unconditionally enabled since 5.5)
	set REFCOUNT_FULL y if $kernel_version >= 4.13 and $kernel_version < 5.5;

	# Check for memory copies that might overflow a structure in str*() and mem*() functions both at build-time and run-time.
	set FORTIFY_SOURCE y if $kernel_version >= 4.13;

	# Dangerous; enabling this allows direct physical memory writing.
	set ACPI_CUSTOM_METHOD n;

	# Dangerous; enabling this disables brk ASLR.
	set COMPAT_BRK n;

	# Dangerous; enabling this allows direct kernel memory writing.
	set DEVKMEM n;

	# Dangerous; exposes kernel text image layout.
	set PROC_KCORE n;

	# Dangerous; enabling this disables VDSO ASLR.
	set COMPAT_VDSO n;

	# Dangerous; enabling this allows replacement of running kernel.
	set KEXEC n;

	# Dangerous; enabling this allows replacement of running kernel.
	set HIBERNATION n;

	# Prior to v4.1, assists heap memory attacks
	set INET_DIAG n if $kernel_version < 4.1;

	# Easily confused by misconfigured userspace, keep off.
	set BINFMT_MISC n;

	# Use the modern PTY interface (devpts) only.
	set LEGACY_PTYS n;

	# If SELinux can be disabled at runtime, the LSM structures cannot be read-only; keep off.
	set SECURITY_SELINUX_DISABLE n;

	# Reboot devices immediately if kernel experiences an Oops.
	set PANIC_ON_OOPS y;
	set PANIC_TIMEOUT -1;


	if $kernel_version >= 4.8 and HAVE_GCC_PLUGINS {
		# Enable GCC Plugins
		set GCC_PLUGINS y;

		# Gather additional entropy at boot time for systems that may not have appropriate entropy sources.
		set GCC_PLUGIN_LATENT_ENTROPY y if $kernel_version >= 4.9;

		# Wipe stack contents on syscall exit (reduces stale data lifetime in stack)
		set GCC_PLUGIN_STACKLEAK y if $kernel_version >= 5.2;

		# Randomize the layout of system structures. This may have dramatic performance impact, so
		# use with caution or also use GCC_PLUGIN_RANDSTRUCT_PERFORMANCE y;
		if $kernel_version >= 4.13 {
			set GCC_PLUGIN_RANDSTRUCT y;
			set GCC_PLUGIN_RANDSTRUCT_PERFORMANCE n;
		}
	}


	if X86 {
		# Enable Kernel Page Table Isolation to remove an entire class of cache timing side-channels.
		set PAGE_TABLE_ISOLATION y if $kernel_version >= 4.15;
	}

	if X86_64 {
		# Disallow allocating the first 64k of memory.
		set DEFAULT_MMAP_MIN_ADDR 65536;

		# Randomize position of kernel and memory.
		set RANDOMIZE_BASE y;
		set RANDOMIZE_MEMORY y if $kernel_version >= 4.8;

		# Modern libc no longer needs a fixed-position mapping in userspace, remove it as a possible target.
		set LEGACY_VSYSCALL_NONE y if $kernel_version >= 4.4;

		# Remove additional attack surface, unless you really need them.
		set IA32_EMULATION n;
		set X86_X32 n;
		set MODIFY_LDT_SYSCALL n if $kernel_version >= 4.3;
	} else if X86 {
		# On 32-bit kernels, require PAE for NX bit support.
		set M486 n;
		set HIGHMEM4G n;
		set HIGHMEM64G y;
		set X86_PAE y;

		# Disallow allocating the first 64k of memory.
		set DEFAULT_MMAP_MIN_ADDR 65536;

		# Randomize position of kernel.
		set RANDOMIZE_BASE y;

		# Don't allow for 16-bit program emulation and associated LDT tricks.
		set MODIFY_LDT_SYSCALL n;
	} else if $arch == "arm64" {
		# Disallow allocating the first 32k of memory (cannot be 64k due to ARM loader).
		set DEFAULT_MMAP_MIN_ADDR 32768;

		# Randomize position of kernel (requires UEFI RNG or bootloader support for /chosen/kaslr-seed DT property).
		set RANDOMIZE_BASE y;

		# Make sure PAN emulation is enabled.
		set ARM64_SW_TTBR0_PAN y if $kernel_version >= 4.10;

		# Enable Kernel Page Table Isolation to remove an entire class of cache timing side-channels.
		set UNMAP_KERNEL_AT_EL0 y if $kernel_version >= 4.16;
	} else if $arch == "arm" {
		# Disallow allocating the first 32k of memory (cannot be 64k due to ARM loader).
		set DEFAULT_MMAP_MIN_ADDR 32768;

		# For maximal userspace memory area (and maximum ASLR).
		set VMSPLIT_3G y;

		# If building an old out-of-tree Qualcomm kernel, this is similar to STRICT_KERNEL_RWX.
		set STRICT_MEMORY_RWX y;

		# Make sure PXN/PAN emulation is enabled.
		set CPU_SW_DOMAIN_PAN y if $kernel_version >= 4.3;

		# Dangerous; old interfaces and needless additional attack surface.
		set OABI_COMPAT n;
	}

	#kernel command line options

	if $kernel_version < 5.3 {
		# Enable slub/slab allocator free poisoning (requires SLUB_DEBUG y; above).
		add_cmdline "slub_debug=P" if SLUB_DEBUG;
	}

	# Disable slab merging (makes many heap overflow attacks more difficult).
	add_cmdline "slab_nomerge";

	# Always enable Kernel Page Table Isolation, even if the CPU claims it is safe from Meltdown.
	add_cmdline "pti=on";
}

module security {
	set SLAB_MERGE_DEFAULT n if $kernel_version >= 4.13;
	if $kernel_version >= 5.2 {
		set STACKLEAK_METRICS n;
		set STACKLEAK_RUNTIME_DISABLE n;
	}
	if $kernel_version >= 4.19 {
		set RANDOM_TRUST_CPU n;
		set PAGE_POISONING_ZERO n;
	}
	#set DEVMEM n;
	set ACPI_CUSTOM_METHOD n;
	set COMPAT_BRK n;
	set DEVKMEM n;
	set COMPAT_VDSO n;
	set BINFMT_MISC n;
	set INET_DIAG n;
	set KEXEC n;
	set PROC_KCORE n;
	set LEGACY_PTYS n;
	set HIBERNATION n;
	set IA32_EMULATION n;
	set X86_X32 n;
	set MODIFY_LDT_SYSCALL n if $kernel_version >= 4.3;
	if $kernel_version >= 5.6 {
		set PTDUMP_DEBUGFS n;
	} else {
		set X86_PTDUMP n;
	}
	set ZSMALLOC_STAT n;
	set PAGE_OWNER n;
	set DEBUG_KMEMLEAK n;
	set BINFMT_AOUT n;
	set KPROBES n;
	set UPROBES n;
	set GENERIC_TRACER n;
	set PROC_VMCORE n;
	set PROC_PAGE_MONITOR n;
	set USELIB n;
	set CHECKPOINT_RESTORE n;
	set USERFAULTFD n if $kernel_version >= 4.3;
	set HWPOISON_INJECT n;
	set MEM_SOFT_DIRTY n;
	set DEVPORT n;
	set DEBUG_FS n;
	set NOTIFIER_ERROR_INJECTION n;
	set ACPI_TABLE_UPGRADE n if $kernel_version >= 4.7;
	set ACPI_APEI_EINJ n;
	set PROFILING n;
	set BPF_SYSCALL n;
	set MMIOTRACE_TEST n;
	set KSM n;
	set KALLSYMS n;
	set X86_VSYSCALL_EMULATION n;
	set MAGIC_SYSRQ n;
	set KEXEC_FILE n;
	set USER_NS n;
	set LDISC_AUTOLOAD n if $kernel_version >= 5.1;
	set MMIOTRACE n;
	set LIVEPATCH n;
	set IP_DCCP n;
	set IP_SCTP n;
	set FTRACE n;
	set BPF_JIT n;
	set BUG y;
	set STRICT_KERNEL_RWX y if $kernel_version >= 4.11;
	set STACKPROTECTOR_STRONG y if $kernel_version >= 4.18;
	set SLUB_DEBUG y;
	set MICROCODE y;
	set RETPOLINE y if $kernel_version >= 4.15;
	set X86_SMAP y;
	if $kernel_version >= 5.5 {
		set X86_UMIP y;
	} else if $kernel_version >= 4.15 {
		set X86_INTEL_UMIP y;
	}
	set IOMMU_SUPPORT y;
	set SYN_COOKIES y;
	set PAGE_TABLE_ISOLATION y if $kernel_version >= 4.15;
	set RANDOMIZE_MEMORY y if $kernel_version >= 4.8;
	set INTEL_IOMMU y;
	set AMD_IOMMU y;
	set VMAP_STACK y if $kernel_version >= 4.9;
	set RANDOMIZE_BASE y;
	set THREAD_INFO_IN_TASK y if $kernel_version >= 4.9;
	set BUG_ON_DATA_CORRUPTION y if $kernel_version >= 4.10;
	set DEBUG_WX y if $kernel_version >= 4.4;
	set SCHED_STACK_END_CHECK y;
	set SLAB_FREELIST_HARDENED y if $kernel_version >= 4.14;
	set SLAB_FREELIST_RANDOM y if $kernel_version >= 4.7;
	set SHUFFLE_PAGE_ALLOCATOR y if $kernel_version >= 5.2;
	set FORTIFY_SOURCE y if $kernel_version >= 4.13;
	if $kernel_version >= 4.8 and HAVE_GCC_PLUGINS {
		set GCC_PLUGINS y;
		set GCC_PLUGIN_RANDSTRUCT y;
		set GCC_PLUGIN_LATENT_ENTROPY y if $kernel_version >= 4.9;
	}
	set DEBUG_LIST y;
	set DEBUG_SG y;
	set DEBUG_CREDENTIALS y;
	set DEBUG_NOTIFIERS y;
	set PAGE_POISONING y;
	set HARDENED_USERCOPY y if $kernel_version >= 4.8;

	if MODULES {
		set STRICT_MODULE_RWX y if $kernel_version >= 4.11;
		set MODULE_SIG y;
		set MODULE_SIG_ALL y;
		set MODULE_SIG_SHA512 y;
		set MODULE_SIG_FORCE y;
	}

	if $kernel_version >= 5.2 and CC_HAS_AUTO_VAR_INIT {
		set INIT_STACK_ALL y;
	} else if $kernel_version >= 5.2 {
		set GCC_PLUGIN_STRUCTLEAK_BYREF_ALL y;
	}
	if $kernel_version >= 5.3 {
		set INIT_ON_ALLOC_DEFAULT_ON y;
		set INIT_ON_FREE_DEFAULT_ON y;
	}
	set SECURITY_DMESG_RESTRICT y;
	set DEBUG_VIRTUAL y;
	set STATIC_USERMODEHELPER y if $kernel_version >= 4.11;
	set GCC_PLUGIN_STACKLEAK y if $kernel_version >= 5.2;
	set INTEL_IOMMU_SVM y if $kernel_version >= 4.4;
	set INTEL_IOMMU_DEFAULT_ON y;
	set SLUB_DEBUG_ON y;
	set RESET_ATTACK_MITIGATION y if $kernel_version >= 4.14;
	set AMD_IOMMU_V2 y;
	set SECURITY y;
	set SECURITY_YAMA y;
	set SECURITY_LOADPIN y if $kernel_version >= 4.7;
	if $kernel_version >= 5.4 {
		set SECURITY_LOCKDOWN_LSM y;
		set SECURITY_LOCKDOWN_LSM_EARLY y;
		set LOCK_DOWN_KERNEL_FORCE_CONFIDENTIALITY y;
	}
	set SECCOMP y;
	if DEVMEM {
		set STRICT_DEVMEM y;
		set IO_STRICT_DEVMEM y if $kernel_version >= 4.5;
	}
	set LEGACY_VSYSCALL_NONE y if $kernel_version >= 4.4;
	set DEFAULT_MMAP_MIN_ADDR "65536";
	set ARCH_MMAP_RND_BITS "32" if $kernel_version >= 4.5;
}
