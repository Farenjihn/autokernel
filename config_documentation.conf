# vim: set ft=ruby ts=4 sw=4 sts=-1 noet:
#
# Configuration format: For an EBNF like description of the config format, refer to
# the config.lark file inside the autokernel python module directory.
#
# You can use ruby syntax highlighting, which gives quite good results, at least in vim.
# In general, the configuration format is not sensitive to whitespace. The comment character is
# '#' which will comment everything until the end of the line.
#
# You can quote strings like "this" or 'this'. In strings, you can use the following escape sequences:
#   \U0001f608      # 8-digit unicode hex escapes
#   \u2665          # 4-digit unicode hex escapes
#   \x1b            # 2-digit hex escapes
#   \033            # Octal escapes
#   \N{Integral}    # Unicode characters by name
#   \\              # Single backslash
#   \"              # "
#   \'              # '
#   \n              # Newline
#   \r              # Carriage Return
#   \t              # Tab
#
# Boolean options recognize the following arguments:
# - false, 0, no,  n, off → false
# - true,  1, yes, y, on  → true
#
# Blocks are enclosed in brackets { }. You do not need to create empty blocks
# if you do not intend to add configurations inside.
# Statements are terminated with a semicolon.

# Include module definitions from a single file. Path can be absolute, or relative to
# the current working directory when executing the script. Using absolute paths is recommended,
# but relative paths can be beneficial when testing different configurations. Module files
# should end with .conf .
#
# This statement may occurr multiple times.
#include_module <path>;
include_module "/usr/share/autokernel/modules.d/security.conf";

# Include module definitions from all .conf files in the given folder.
# Path can be absolute or relative.
# This statement may occurr multiple times.
#include_module_dir <path>;
include_module_dir "/etc/autokernel/modules.d";

# Defines a new module with the specified name.
# Modules can be included in other modules to provide a level
# of encapsulation for different tasks.
#module <name> { ... }
module my_module {
	# # Pinning option values
	#
	# In autokernel's philosophy, any option can only be changed once. In the beginning,
	# all options will start with their default values, as specified in the kernel's Kconfig.
	#
	# Any evaluation or assignment to an option will pin (fix) its value, and successive
	# changes will become hard errors. This allows modules to use logic based on option values,
	# without imposing implicit ordering constraints, or surprise pitfalls down the road.
	# Wrong ordering will lead to errors instead of doing the wrong thing silently.
	#
	# ## Example
	#
	# Consider this example:
	#
	# module external {
	#	if A {
	# 	  set B y;
	# 	} else {
	# 	  set B n;
	# 	}
	# }
	#
	# module foo {
	#	set A y;
	#	use external;
	# }
	#
	# module bar {
	#	use external;
	#	set A y;
	# }
	#
	# Now consider A is n by default. In traditional imperative languages,
	# using module foo would result in A and B being y, which is consistent with the
	# constaint in externals. But when using bar, B would be set to n while A would
	# still be y, which violates the condition in the external module retrospectively.
	#
	# Therefore, autokernel will pin option values both when encountered in an expression
	# and when set explicitly. Using foo will result in A = B = y, while using bar will result
	# in an error, because A is pinned to 'n' in the condition 'if A', and changed later when
	# it is set to y. (Reassigning the same value to an option which it already holds is not
	# an error by design, because it is not a conflict). This means that all configurations
	# which have conflicts will throw hard errors, previous assumption will never be invalidated.
	#
	# If the external module would like to impose a different default value than the kernel
	# default, it can do 'try set A y;' before the condition, which will only change the value,
	# if it hasn't been pinned yet.
	#
	#
	# # Option dependencies
	#
	# Some options have dependencies, which will be invalidated when the option is
	# assigned. One example is MODULES. When you set MODULES to n, it will cause a lot of
	# implicit changes in all options which are configured as m to either n or y. These
	# changes will not pin their option's value, but they will conflict if the
	# value is already pinned and would be changed.
	#
	#
	# # Conditions
	#
	# Statements in module blocks may have conditions attached to them. They will
	# only be executed if all conditions are met.
	#
	# Conditions are expressions in traditional form, operator precedence is
	# not, and, or. The following expressions are allowed:
	#  - A or  B, A || B    # (A ∨ B)
	#  - A and B, A && B    # (A ∧ B)
	#  - A or B and C       # (A ∨ (B ∧ C))
	#  - not A, !A          # ¬A
	#  - A                  # Shorthand for A != 'n'
	#  - A == B, A is B     # A is     equal to B
	#  - A != B  A is not B # A is not equal to B
	#  - A <= B             # A is less    than or equal to B
	#  - A <  B             # A is less    than             B
	#  - A >= B             # A is greater than or equal to B
	#  - A >  B             # A is greater than             B
	#
	#  All comparison operators can be chained: A <= B <= C, or even A != B != C, and are
	#  always exactly the same as writing them in expanded form like A <= B and B <= C,
	#  or A != B and B != C. Autokernel will fold these expressions and compare results of
	#  intermediate truth values.
	#
	# ## Comparisons and variable types
	#
	# All expressions boil down to comparisons, and how variables are compared depends
	# on their type:
	#  - Literals have no type and will inherit the type from the rest of the expression.
	#  - Kernel options and special variables have fixed types.
	#  - Comparing two literals will always fall back to string comparison.
	#
	# ### Comparison types
	#
	# - string   → does lexicographical comparison
	# - int      → integer comparison, base 10
	# - hex      → integer comparison, base 16, and requires 0x prefix.
	# - tristate → same as string, but restricts arguments to n, m, y
	# - semver   → semantic versioning comparison, format is major[.minor[.patch[-ignored]]],
	#              4 is the same as 4.0.0
	#
	# Have a look at the following comparisons, their comparison type and their validity:
	# - SOME_STRING     == abc   (string, valid)
	# - SOME_STRING     == "abc" (string, valid)
	# - SOME_STRING     <= "abc" (string, invalid operator for string)
	# - SOME_STRING     <   1    (string, invalid operator for string)
	# - SOME_INT        <   1    (int, valid)
	# - SOME_INT        <  "1"   (int, valid)
	# - SOME_HEX        <=  1    (hex, invalid prefix)
	# - SOME_HEX        ==  0x1  (hex, valid)
	# - SOME_TRISTATE   == 'n'   (tristate, valid)
	# - SOME_TRISTATE   == 'm'   (tristate, valid)
	# - SOME_TRISTATE   == 'y'   (tristate, valid)
	# - 12345           !=  12   (string, valid)
	# - $kernel_version >=  5.6  (semver, valid)
	#
	#
	# ## Special comparison variables
	#
	# There are several special variables which must be used in unquoted form
	# and will allow you to depend on runtime information.
	#
	# | Variable        | Type     | Description                                                                          |
	# |-----------------|----------|--------------------------------------------------------------------------------------|
	# | $kernel_version | semver   | Expands to the semver of the specified kernel                                        |
	# | $uname_arch     | string   | The uname as reported by uname -m                                                    |
	# | $arch           | string   | The architecture as seen by the kernel internally (e.g. x86 for both x86 and x86_64) |
	# | $false          | tristate | Always 'n'                                                                           |
	# | $true           | tristate | Always 'y'                                                                           |
	#
	#
	# ## Short-circuiting (early-out)
	#
	# All expressions support short-circuiting. The main reason is that you can do conditional
	# pinning with short circuiting.
	#
	# Consider the symbol USB4, which was first introduced in kernel 5.6. The statement
	#	if USB4 { ... }
	# would fail on older kernels, since the symbol USB4 cannot be found there.
	# If you change the statement to
	#	if $kernel_version >= 5.6 and USB4 { ... }
	# the USB4 will only be evaluated when the kernel version constraint is already met.
	# This allows the code to be used on all kernel versions.
	#
	# ## Using conditions
	#
	# Conditions can be used in traditional block form with optional else if and else clauses,
	# or as python like trailing inline conditions. The block form can of course be nested, and
	# styles can be mixed.
	#
	# ### Block form
	#
	# if <expression> {
	#	set A y;
	# } else if <expression> {
	#	set A n;
	# } else {
	#	set B n;
	#	set C n;
	# }
	#
	# ### Inline form
	#
	# set A y if <expression>;
	#
	# Is the same as
	#
	# if <expression> { set A y; }

	# Common variables:
	#  - {KERNEL_DIR}     the current kernel directory path.
	#  - {KERNEL_VERSION} the current kernel version.
	#  - {ARCH}           the host architecture as the kernel sees it
	#  - {UNAME_ARCH}     the host architecture as uname -m reports it

	# Include a module at this point. Modules can be defined in any order, so
	# names don't need to be available at point of use. Any module can only be used
	# once, as option pinning guarantees that a duplicate inclusion leads to the same
	# result. Therefore, modules will be included in the order they are encountered in
	# use statements, while cyclic and duplicate inclusions are impossible.
	# This statement may occurr multiple times.
	#use <module1> [<module2>]... [if <expr>];
	use my_first_dependency my_second_dependency;
	use my_third_dependency;

	# Set an option's value.
	# Omitting the value will default to setting the symbol to 'y'.
	# Prefixing option names with CONFIG_ is allowed, but considered bad style.
	#
	# If the statement is prefixed with 'try', it will only be executed if the value is not
	# already pinned, and the assignment will not cause the value to be pinned. Useful
	# to impose a new default value for a symbol but still allowing the user to change it.
	#
	# Multiple assignment of the same option is valid, as long as the
	# same value is assigned, or the assignment has the try prefix.
	# Conflicts will cause hard errors.
	#[try] set [CONFIG_]<kernel_option> [value] [if <expr>];
	set USB4 y if $kernel_version >= 5.6;
	set KVM m;
	set MODULES n;
	set MAGIC_SYSRQ_DEFAULT_ENABLE 0x1;
	set DEFAULT_MMAP_MIN_ADDR 65536;
	set DEFAULT_HOSTNAME "my_host";

	# Merge an exteral kernel configuration file. This can be a whole .config or just
	# a collection of some options as it is the case for the defconfig files.
	# All merged values will count as implicit changes (no pinning) and will trigger
	# conflicts if a variable is already pinned.
	#
	# Variables: See common variables
	#merge <path> [if <expr>];
	merge "{KERNEL_DIR}/arch/x86/configs/x86_64_defconfig";

	# Asserts that a given expression evaluates to true, otherwise causes an error
	# and prints the message (if given).
	#assert <expr> ["error-message"] [if <expr>];
	assert $kernel_version >= 5.6 and WIREGUARD "Refusing to compile a 5.6 kernel without wireguard";

	# Adds the given parameters to the kernel commandline. This will automatically set
	# CMDLINE to the resulting string and enable CMDLINE_BOOL.
	#add_cmdline <param>... [if <expr>];
	add_cmdline "page_alloc.shuffle=1" "second_param" "third_param";
}

# A block for kernel related options. Multiple appearances of this block will be merged.
# Has the same options as any other module.
#kernel { ... }
kernel {
	# This special module will automatically be included and executed first.
	use my_module;
}

# A block for initramfs related options. Multiple appearances of this block will be merged.
#initramfs { ... }
initramfs {
	# Enables or disables building of an initramfs.
	# Default: false
	#enabled <bool>;
	enabled true;
	# This will integrate the initramfs directly into the kernel. It will
	# cause an automatic second kernel build pass, to first allow the initramfs
	# to include any modules for the current kernel, and secondly to pack the initramfs
	# into the kernel. The second build will not require any rebuilds of previously
	# compiled componends, and should thus be quick.
	# Default: false
	#builtin <bool>;
	builtin true;

	# Required if enabled. The command used to build the initramfs. The resulting initramfs should either be directly
	# placed at {INITRAMFS_OUTPUT}, otherwise you can use the 'command_output' statement to specify
	# where it will be afterwards.
	#
	# Each string is a separate argument, and arguments will not be interpreted or split on spaces.
	# If you need more logic here, please execute a script.
	#
	# Variables:
	#  - Any common variable (See common variables)
	#  - {MODULES_PREFIX} A directory which contains all installed modules.
	#    This means {MODULES_PREFIX}/lib/modules exists and can be used by the initramfs generator
	#    to include newly compiled modules for the kernel.
	#  - {INITRAMFS_OUTPUT} the desired output file. If your generator doesn't support this, you
	#    can specify an alternate location with command_output.
	#command <exe> [<param>...];
	command "build_initramfs.sh" "{INITRAMFS_OUTPUT}";
	# Optional. Specifies where the output from the initramfs command will be. You do not need
	# to specify this, if your generator placed the initramfs at location given via {INITRAMFS_OUTPUT}
	#
	# Variables: Same as for command.
	#command_output <path>;
	command_output "/tmp/genkernel/initramfs.img";

	# Example command to build a initramfs with dracut
	command "dracut"
		"--conf"          "/dev/null"
		"--confdir"       "/dev/null"
		"--kmoddir"       "{MODULES_PREFIX}/lib/modules/{KERNEL_VERSION}"
		"--kver"          "{KERNEL_VERSION}"
		"--no-compress"
		"--hostonly"
		"--hostonly-mode" "strict"
		"--no-hostonly-cmdline"
		"--ro-mnt"
		"--modules"       "bash crypt crypt-gpg"
		"--force"
		"{INITRAMFS_OUTPUT}";

	# Example command to build an initramfs with genkernel
	command "genkernel"
		"--module-prefix=${MODULES_PREFIX}"
		"--cachedir=/tmp/genkernel/cache"
		"--tmpdir=/tmp/genkernel"
		"--logfile=/tmp/genkernel/genkernel.log"
		"--kerneldir={KERNEL_DIR}"
		"--no-install"
		"--no-mountboot"
		"--no-compress-initramfs"
		"--no-ramdisk-modules"
		"--luks"
		"--gpg"
		"initramfs";
	command_output "/tmp/genkernel/initramfs-{UNAME_ARCH}-{KERNEL_VERSION}";
}

# A block for build related options. Multiple appearances of this block will be merged.
#build { ... }
build {
	# The umask used while building the kernel and the initramfs.
	# Default: 0022
	#umask <value>;
	umask 0022;

	# Optional. A block for hooks. Multiple appearances of this block will be merged.
	#hooks { ... }
	hooks {
		# Optional. Defines a pre-build hook.
		# If the hook returns an unsuccessful exit code, autokernel will abort.
		# Variables: See common variables
		#pre <exe> [<param>...];
		pre  "echo" "build.pre";
		# Optional. Defines a post-build hook.
		# If the hook returns an unsuccessful exit code, autokernel will abort.
		# Variables: See common variables
		#post <exe> [<param>...];
		post "echo" "build.post";
	}
}

# A block for install related options. Multiple appearances of this block will be merged.
#install { ... }
install {
	# The umask used while installing files into the system.
	# Default: 0077
	#umask <value>;
	umask 0077;

	# Asserts that the given directory is a mountpoint. Otherwise, autokernel will
	# abort installation.
	#assert_mounted <path>;
	assert_mounted "/boot/efi";

	# Temporarily mounts the given directory. Will be unmounted after installation, in
	# case it had to be mounted. Requires an fstab entry. Autokernel will abort if
	# the directory could not be mounted. If you use this, an additional assert_mounted
	# entry is unnecessary.
	#mount <path>;
	mount "/boot/efi";

	# The target installation directory. All other target_ statements will be relative
	# to this directory. Must be an absolute path.
	# Variables: See common variables
	# Default: "/boot"
	#target_dir <path>;
	target_dir "/boot";
	target_dir "/boot/efi/EFI";

	# The target path for the kernel image. This is relative to target_dir, but
	# may also be an absolute path if desired. Installation can be disabled by
	# setting this to any false <bool> representation.
	# Variables: See common variables
	# Default: "bzImage-{KERNEL_VERSION}"
	#target_kernel <path>|<bool>;
	target_kernel false;
	target_kernel "bzImage-{KERNEL_VERSION}";

	# Same as target_kernel, but for the generated kernel configuration file.
	# Variables: See common variables
	# Default: "config-{KERNEL_VERSION}"
	target_config off;
	target_config "config-{KERNEL_VERSION}";

	# Same as target_kernel, but for the initramfs file (only if initramfs is enabled).
	# Variables: See common variables
	# Default: "initramfs-{KERNEL_VERSION}.cpio"
	target_initramfs no;
	target_initramfs "initramfs-{KERNEL_VERSION}.cpio";

	# The prefix path for make modules_install. This must an absolute path.
	# Variables: See common variables
	# Default: "/"
	modules_prefix "/";

	# Automatic purging of old files. Determines the amount of kernels to keep.
	# Only has an effect on target_dir and targets_* when {KERNEL_VERSION} is used
	# in the path. A negative value -1 disables purging completely (default).
	# Default: -1
	keep_old 2;

	# Analog to build.hooks, but for installation.
	hooks {
		pre  "echo" "install.pre";
		post "echo" "install.post";
	}
}
